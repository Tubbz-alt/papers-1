\section{System Overview}
%
\begin{figure}[bt]
  \begin{center}
%    \includegraphics[width=0.9\linewidth]{images/system.png}
  \end{center}
  \caption{The complete system overview}
  \label{fig:system}
\end{figure}
%
\subsection{Interactions and Responsibilites}
\subsubsection{Themes and External Resources}
The FBTheme class is implemented as flyweight, holding references to previously 
created instances of a particular theme. If a requested theme type is not yet 
held in the list of instances, the class calls a builder class, 
FBThemeBuilder~\ref{fig:system}(1), to parse the requested theme's XML file, 
load the images and then return a fresh instance of the theme. Additionally, 
each theme contains an FBImageLibrary. The image library is just a simple 
wrapper around an IdentityDictionary to ease filling it with Forms. 
FBTheme and FBImageLibrary also support scaling to adjust to any screen 
size (without accounting for neccessary interpolation).
The FBImageLibrary is filled prior to starting the actual game, so 
that all external resources are cached. A lazily initialized image 
library would have resulted in slow disk I/O during
run-time.
\subsubsection{Rewarding the Players}
FBRewardStrategies are supporting classes which add rewarding behaviour 
to the game logic
~(Fig.\ref{fig:system}(2)). Its specializations 
implement different strategies to
reward the players for good gaming. Good gaming is measured by the 
number of balls falling, if more are falling at the same time, more 
reward points are gained.
The reward strategies have to implement a method
rewardPlayer:for:~\ref{lst:reward}.\\
In single player mode, a FBHighscoreReward
adds a simple highscore to the screen (responsible for adding the 
score visual is also the strategy itself) and for any number of 
reward points reported by the FBPlayfield, score points are accumulated.
%
\begin{figure}
  \begin{center}
    \begin{lstlisting}
FBHighscoreReward>>rewardPlayer: aPlayer for: anAchievmentScalar
    "I reward a single player with an exponentially 
rising rate of points" 

    self score:
         self score + (anAchievmentScalar raisedTo: 2)
    \end{lstlisting}
  \end{center}
  \caption{The highscore calculation method}
  \label{lst:reward}
\end{figure}
In multiplayer mode, the strategie only rewards, if the player eliminates 
more than three balls from the field with a single shot. If that happens, 
a number of balls half as great is distributed among the other players,
and shot randomly in any direction. This happens via a call to 
the playfields which have to shoot random balls, since FBRewardStretegies
hold a collection referring to all playfields.
%
\subsubsection{Playfield Morphs}
As aforementioned, FBPlayfield is responsible for creating its own 
contents~\ref{fig:system}(3). Such content displays a cannon, a 
player avatar , messages for the user and numerous coloured balls. 
Each of these serves only a single, limited purpose, with FBPlayer 
and FBMessage merely wrapping different types of graphical response.
The cannon is the entity that reacts to the user's input, panning 
left and right and sending balls off into the field. However, it 
is controlled entirely by the playfield and does not act itself.

The FBBall is an exception to this simplicity. 
\begin{description}
  \item[First]
    	it has to look 
	differently, showing different colors in our themes. 
  \item[Secondly]
    	a Ball has different stages in its lifetime, being 
	loaded into the cannon, then flying, hanging from the 
	ceiling (or, indeed, from other balls) and finally falling 
	and vanishing.
  \item[Finally]
    	a Ball needs to collide with the playfield boundaries and 
	other balls in the field.
\end{description}
Thus its implementation is a bit larger, as it implements the FBCollider 
interface, utilizes different ``states'' to act on in its step method and 
and also draws itself from a collection of images.
%
\subsection{FBCollisionMap}
%
\subsection{FBSweeper}
As discussed in \ref{sec:garbage}, the first design planned for every Collider to keep track of all Objects it holds on to and all Objects that hold on to it. When an Object falls down, it informs the objects that hold on to it, that they lost one Holder. When an Object has lost its last Holder, it should itself fall down and inform all objects that hold on to it that it is gone.
This approach had several drawbacks. First, the logic for this falling down was distributed over the CollisionMap, Collider and Ball classes.
Second, every Collider observed the Colliders next to it. When a Collider was removed from the structure, the observing Colliders removed it from their lists of holders. In the event that a Collider had no holders, it fell down, thereby invoking events on its observing neighbours.
This resulted in a control flow that was hard to understand, as the information of the removal of a Collider was propagated to the other Colliders implicitly through events and not explicitly through message sends.
Third, reference-counting garbage collectors have a well-known problem with cyclic references. 

\begin{lstlisting}[language=Smalltalk]
FBSweeper>>sweep: aCollisionMap
    "Sweep balls that do not hang on anything off the playfield"
    |gcLive gcCollect|
    gcCollect := gcArena copy.
    gcLive := gcRoots copy.
    [gcLive isEmpty] whileFalse:[
       gcLive copy do: [:eachLiveBall|
           gcLive remove: eachLiveBall.
           (gcCollect includes: eachLiveBall) ifTrue:[
               gcCollect remove: eachLiveBall.
               gcLive addAll: (aCollisionMap holdersFor: eachLiveBall center)
           ]
       ]
    ].
    gcCollect do:[:eachBall | eachBall fall].
\end{lstlisting}




