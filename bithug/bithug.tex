\documentclass{llncs}
\usepackage{makeidx}  % allows for indexgeneration
\usepackage[pdftex]{graphicx} % PNGs
\usepackage{amsmath, amssymb} % algebra
\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc} 
\usepackage[procnames]{listings} % for sourcecode
\usepackage{graphviz} % graphs
\usepackage{array,multirow} % tables
\usepackage{afterpage} % figures
\usepackage{float} % figures

\lstset{%
	basicstyle=\small\ttfamily,
	language=Ruby,
	frame=lines,
	numbers=left,
	numberstyle=\rmfamily\tiny,
	numbersep=3pt,
	breaklines=true,
	breakatwhitespace=true
}

\restylefloat{figure}
\begin{document}
\pagestyle{headings}  % switches on printing of running heads
\mainmatter % start of the contributions
\title{Bithug - Social Coding}
\subtitle{A Code Repository Management Platform for Social Networks}
\titlerunning{Bithug}  % abbreviated title (for running head)
\author{Tim Felgentreff~ Konstantin Haase~ Johannes Wollert}
\date{\today}
\authorrunning{Felgentreff, Haase, Wollert}   % abbreviated author list (for running head)
\tocauthor{Tim Felgentreff (Hasso-Plattner-Institute)\\
	   Konstantin Haase (Hasso-Plattner-Institut)\\
	   Johannes Wollert (Hasso-Plattner-Institut)}
\institute{Social Web Applications Engineering, Internet Technologies and Systems, Hasso-Plattner-Institut, UniversitÃ¤t Potsdam, D-14482 Potsdam, Germany,\\
\email{\{tim.felgentreff, konstantin.haase, johannes.wollert\}@student.hpi.uni-potsdam.de}}

\maketitle
\begin{abstract}

\end{abstract}
\section{Introduction}

\section{Project Management as a Service}
DVCS/Git, Our plans, alternatives (Gitorious, GitHub FI, Gitauth)

\section{Technical Stuff}

\subsection{The Stack}
Our project split into three major subprojects: Bithug (out actual project), BigBand (parts of Bithug you can use in any Sinatra Project), MonkeyLib (parts you can use in any Ruby project).

Patched versions of krb5-auth (currently unmaintained) and Ohm.

Other libraries we use: ...

Stack is known to work on ...

\subsection{Persistence}
\subsubsection{Why no RDBS?}
Traditionally, databases have focused on storing relational datasets. 
Relational storage has the advantage, that data retrieval can be formulated in 
a declarative way. These declaration can then be mathemtically optimized for 
to meet specific time/space-constraints.
Though relational datasets do not lend themselves very well to object-oriented 
web-programming developers have gone to great length to provide easy-to-use 
object-relational-mappers (ORM) to support RDBS storage in object-oriented 
applications. Popular patterns in ORMs are the ActiveRecord-Pattern\cite{citation needed} 
and DataMapper\cite{citation-needed}.

There are several problems with this
\begin{enumerate}
  \item Going through an object-oriented language and mapping objects to 
    relations will usually lead to many smaller queries instead of large 
    ones, leaving less room for the RDBS to optimize. 
  \item Mapping the dynamics of object-inheritance requires stunts like 
    STI/MTI which either store more data than needed or are less efficient in 
    their data-retrieval methods needing large joins to re-create objects.
  \item Dynamic objects with polymorphic attributes require join- and 
    attribute-tables which further reduce the performance of the RDBS.
  \item Populated databases can be very difficult to migrate when the software 
    evolves further away from the premier data-model.
\end{enumerate}

The rich-configurability we were aiming for with Bithug would require us to 
provide migration strategies for setups changing their configurations as well 
keeping the mapping general enough to allow easy transitions when implementing 
new services.
\subsubsection{A promising alternative: Maglev}
Maglev is a Ruby implementation atop GemStone/S, the Smalltalk 
object-persistence system. GemStone is an object-oriented database able to 
serialize objects in the runtime environment transparently, taking care of 
object-references and garbage-collection automatically.

GemStone is not a new system\cite{citation needed} for persistence, but only
in recent years has it become sufficiently advanced to compete with traditional
RDMS speed-wise. Its great strength is the built-in support for 
object-orientation: anything the language can do, the server can persist. Using
Maglev would have solved the problem of persistence. However, Maglev is a very 
young implementation of Ruby and it does not yet support enough of the features
we require in Bithug, most importantly the CSS-compiled style-sheet language 
SASS and the Kerberos authentication plug-in we provide for company networks.
\subsubsection{Key-Value-Stores}
Key-value stores have emerged in the last few years as an alternative to 
relational database management systems for some data storage tasks. 
Redis, BigTable, and Casandra are just three of the players in this buzzing
area of database systems. Key-value stores promise to solve the problems we 
met while writing Bithug:
\begin{enumerate}
  \item Fast for a great many small queries
  \item Moderate hardware requirements for small setups
  \item Easy scalability through sharding
  \item Atomic operations and automatic consistency
  \item Elastic, yet simple data model which is easily extensible at runtime
\end{enumerate}

At the most basic level, key-value stores are really simply what the name 
suggests, that is, simple hash-maps or trees which map keys to values. Those 
structures have very fast lookup times for simple key and range queries though 
they get considerably slower and memory hungry when larger and more diverse 
queries are involved. However, if the main task of a persistance layer will be
retrieving values for keys or ranges of keys, these structures \emph{will} 
be\cite{citation needed} considerable faster than RDBS.

KV-stores like CouchDB or MongoDB provide REST-interfaces to their 
databases. This allows them to be easily replicated behind a load-balancer 
leading to virtually unlimited scalability. Additionally, the data-structures 
and their applications for storage are limited, but simple 
and do not require difficult setup or up-to-date hardware. 

For a web-application starting with
moderate budget and growing over time this is the optimal scenario where the 
return-on-investment can literally be met by the first customer paying for one 
server.



why redis -> simple (Casandra, Tokyo Cabinet), not AGPL (MongoDB), fast/more reliable (CouchDB)

\subsection{Sinatra}
Sinatra vs. Rails/Merb/Redis
Complexity, enforcing usage, code generation sucks.
BigBand

\subsection{Using dynamic inheritance as means of configuration}
In class-based object-oriented programming inheritance is often used as specialization.
For instance, in an application managing costumers, the class Costumer might have the same
superclass as the class Administrator, as they might share some common logic and attributes.

This behavior can be used for application configuration, where one configuration option can be seen
as a special class inheriting from a more general Application class. In our application we use this
approach for our two core classes: User and Repository.

For instance: You want to use Kerberos authentication. With the previous explanation it could be possible
to have a Kerberos::User class, inheriting from Bithug::User, overwriting the authentication method.
This is actually very close to what we do internally. As you might suspect this approach fails when offering
combinable options. What if you to offer Kerberos and LDAP authentication both as stand-alone solution or
on as a fallback for the other (which is a typical network setup, in our experience). In a language that offers
multiple inheritance, you could create the classes Kerberos::User and Ldap::User, that both inherit from Bithug::User
and than create the classes KerberosWithLdapFallback::User and LdapWithKerberosFallback::User both inheriting
from Kerberos::User and Ldap::User. Would this language not be able to define classes at runtime, it would even be
more complicated, as you would have to generate all possible combinations at compile time. Ruby however does offer
runtime creation of classes. But it does lack multiple inheritance.

A third approach would be to change a classes inheritance chain by altering its superclass at runtime (or at compile
time, for that matter, which would be less dynamic). Upfront: Even though this is possible in most Ruby implementations,
it is considered extremely dangerous\footnote{Apart from maybe even seriously breaking your object space, you would have
to clear a couple of caches used by the underlying Ruby implementation to speed up method dispatch.}, and is not used
by Bithug. It should still be explained, as it helps to understand our implementation for not familiar with the Ruby
method dispatch. Let us take the above example: To configure a system that would first try to authenticate against Kereberos
and if that fails try LDAP authentication, you could change the superclass of Kerberos::User to Ldap::User which still
is a subclass of Bithug::User. If you implement a method Bithug::User.authenticate(login, password), that should return
true if authentication succeeds and false otherwise. Now, if Bithug::User.authenticate always returns false and both
Kerberos::User.authenticate and Ldap::User.authenticate return true if the authentication against LDAP/Kerberos succeeds,
the result of their superclass's authenticate the setup would be complete. This approach is somewhat comparable to context-
or aspect-oriented programming, where you are able to wrap aspects around an object.

Ruby supports a concept called Mixins. Mixins are one use case for Ruby modules\footnote{Others are namespacing and classes
without instances.}. A Ruby module is defined like a Ruby class. You can define both instance and singleton methods\footnote{Methods
defined on class side, also known as class methods.}. However, as you cannot instantiate a module, its instance methods
are not directly usable. You can include such a module in a class. It is a common misbelieve â even among long time rubyists â that
by doing so the unbound methods\footnote{Ruby term for not yet belonging to an object, thus not being callable.} are copied
to the class and by doing so overwriting existing methods. In reality when including a module in a class, a new class is
created, containing all the modules instance methods. That class is inserted in the inheritance chain in-between the original
class and its superclass (or previously included modules). This allows a similar usage as changing the superclass without its
complication.

However, if you followed the above explanation closely, you might already see two major issues with that approach. As mentioned,
only the instance methods become part of the new class. The singleton methods are already bound to the module and cannot be
rebound to the class. The solution is a common pattern one will often fine in ruby programs: Use another mixin for the class methods
and include that mixin in the singleton class\footnote{A class every object in ruby has. It keeps all the singleton methods of an
object as instance methods and has that object as sole instance â hence singleton class.}.

The other problem is, that a module is inserted after the class in the inheritance chain, not in front of it. In the Kerberos/LDAP
example, Bithug::User.authenticate would always return false, since the Kerberos and LDAP implementations never get called. Our
solution to that is to have an empty class (i.e. without method definitions) called Bithug::User subclassing Bithug::AbstractUser.
All our common logic is placed inside AbstractUser. Now, if we include a module in Bithug::User, it is inserted in front of AbstractUser
in the inheritance chain, thus getting called.

\section{WTF}

\subsection{Scalability in Heterogeneous Environments}

WTF?

\section{Social Networks as Organizing Bodies}
WTF?

\subsection{The Lazy Web Concept}
WTF?

\subsection{Decentralization of Responsibilities}
WTF?

\subsection{Community-driven Innovation}
WTF?

\end{document}
