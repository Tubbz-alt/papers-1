\documentclass{llncs}
\usepackage{makeidx}  % allows for indexgeneration
\usepackage[pdftex]{graphicx} % PNGs
\usepackage{amsmath, amssymb} % algebra
\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc} 
\usepackage[procnames]{listings} % for sourcecode
\usepackage{graphviz} % graphs
\usepackage{array,multirow} % tables
\usepackage{afterpage} % figures
\usepackage{float} % figures

\lstset{%
	basicstyle=\small\ttfamily,
	language=Ruby,
	frame=lines,
	numbers=left,
	numberstyle=\rmfamily\tiny,
	numbersep=3pt,
	breaklines=true,
	breakatwhitespace=true
}

\restylefloat{figure}
\begin{document}
\pagestyle{headings}  % switches on printing of running heads
\mainmatter % start of the contributions
\title{Bithug - Social Coding}
\subtitle{A Code Repository Management Platform for Social Networks}
\titlerunning{Bithug}  % abbreviated title (for running head)
\author{Tim Felgentreff~ Konstantin Haase~ Johannes Wollert}
\date{\today}
\authorrunning{Felgentreff, Haase, Wollert}   % abbreviated author list (for running head)
\tocauthor{Tim Felgentreff (Hasso-Plattner-Institute)\\
	   Konstantin Haase (Hasso-Plattner-Institut)\\
	   Johannes Wollert (Hasso-Plattner-Institut)}
\institute{Social Web Applications Engineering, Internet Technologies and Systems, Hasso-Plattner-Institut, UniversitÃ¤t Potsdam, D-14482 Potsdam, Germany,\\
\email{\{tim.felgentreff, konstantin.haase, johannes.wollert\}@student.hpi.uni-potsdam.de}}

\maketitle
\begin{abstract}
\end{abstract}
\section{Introduction}

\section{Project Management as a Service}
DVCS/Git, Our plans, alternatives (Gitorious, GitHub FI, Gitauth)

\section{Technical Stuff}

\subsection{The Stack}
Our project split into three major subprojects: Bithug (out actual project), BigBand (parts of Bithug you can use in any Sinatra Project), MonkeyLib (parts you can use in any Ruby project).

Patched versions of krb5-auth (currently unmaintained) and Ohm.

Other libraries we use: ...

Stack is known to work on ...

\subsection{Persistence}
\subsubsection{Why no RDBS?}
Traditionally, databases have focused on storing relational datasets. 
Relational storage has the advantage, that data retrieval can be formulated in 
a declarative way. These declaration can then be mathemtically optimized for 
to meet specific time/space-constraints.
Though relational datasets do not lend themselves very well to object-oriented 
web-programming developers have gone to great length to provide easy-to-use 
object-relational-mappers (ORM) to support RDBS storage in object-oriented 
applications. Popular patterns in ORMs are the ActiveRecord-Pattern\cite{citation needed} 
and DataMapper\cite{citation-needed}.

There are several problems with this
\begin{enumerate}
  \item Going through an object-oriented language and mapping objects to 
    relations will usually lead to many smaller queries instead of large 
    ones, leaving less room for the RDBS to optimize. 
  \item Mapping the dynamics of object-inheritance requires stunts like 
    STI/MTI which either store more data than needed or are less efficient in 
    their data-retrieval methods needing large joins to re-create objects.
  \item Dynamic objects with polymorphic attributes require join- and 
    attribute-tables which further reduce the performance of the RDBS.
  \item Populated databases can be very difficult to migrate when the software 
    evolves further away from the premier data-model.
\end{enumerate}

The rich-configurability we were aiming for with Bithug would require us to 
provide migration strategies for setups changing their configurations as well 
keeping the mapping general enough to allow easy transitions when implementing 
new services.
\subsubsection{A promising alternative: Maglev}
Maglev is a Ruby implementation atop GemStone/S, the Smalltalk 
object-persistence system. GemStone is an object-oriented database able to 
serialize objects in the runtime environment transparently, taking care of 
object-references and garbage-collection automatically.

GemStone is not a new system\cite{citation needed} for persistence, but only
in recent years has it become sufficiently advanced to compete with traditional
RDMS speed-wise. Its great strength is the built-in support for 
object-orientation: anything the language can do, the server can persist. Using
Maglev would have solved the problem of persistence. However, Maglev is a very 
young implementation of Ruby and it does not yet support enough of the features
we require in Bithug, most importantly the CSS-compiled style-sheet language 
SASS and the Kerberos authentication plug-in we provide for company networks.
\subsubsection{Key-Value-Stores}
Key-value stores have emerged in the last few years as an alternative to 
relational database management systems for some data storage tasks. 
Redis, BigTable, and Casandra are just three of the players in this buzzing
area of database systems. Key-value stores promise to solve the problems we 
met while writing Bithug:
\begin{enumerate}
  \item Fast for a great many small queries
  \item Moderate hardware requirements for small setups
  \item Easy scalability through sharding
  \item Atomic operations and automatic consistency
  \item Elastic, yet simple data model which is easily extensible at runtime
\end{enumerate}

At the most basic level, key-value stores are really simply what the name 
suggests, that is, simple hash-maps or trees which map keys to values. Those 
structures have very fast lookup times for simple key and range queries though 
they get considerably slower and memory hungry when larger and more diverse 
queries are involved. However, if the main task of a persistance layer will be
retrieving values for keys or ranges of keys, these structures \emph{will} 
be\cite{citation needed} considerable faster than RDBS.

KV-stores like CouchDB or MongoDB provide REST-interfaces to their 
databases. This allows them to be easily replicated behind a load-balancer 
leading to virtually unlimited scalability. Additionally, the data-structures 
and their applications for storage are limited, but simple 
and do not require difficult setup or up-to-date hardware. 

For a web-application starting with
moderate budget and growing over time this is the optimal scenario where the 
return-on-investment can literally be met by the first customer paying for one 
server.



why redis -> simple (Casandra, Tokyo Cabinet), not AGPL (MongoDB), fast/more reliable (CouchDB)

\subsection{Sinatra}
Sinatra vs. Rails/Merb/Redis
Complexity, enforcing usage, code generation sucks.
BigBand

\subsection{Using dynamic Inheritance as means of configuration}
Mixins and stuff

\section{WTF}

\subsection{Scalability in Heterogeneous Environments}
WTF?

\section{Social Networks as Organizing Bodies}
WTF?

\subsection{The Lazy Web Concept}
WTF?

\subsection{Decentralization of Responsibilities}
WTF?

\subsection{Community-driven Innovation}
WTF?

\section*{Acknowledgments}
\bibliographystyle{splncs}
\bibliography{bibtex}
\clearpage
\end{document}
